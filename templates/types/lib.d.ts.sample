//#region Lib.Types
declare namespace Lib.Types {
  type ClassDef = new (...args: *[]) => *
  type MethodDef<T> = (...args: *[]) => T
  //#region Json
  namespace Json {
    type Value = string | number | boolean | null | Json | Json[]
  }
  type Json = { [k: string]: Json.Value } | Json.Value[]
  //#endregion
  //#region AppCall
  namespace AppCall {
    type Request = { id: string; payload: Types.Json; org?: string }
    namespace Response {
      type Status = 'success' | 'error'
      namespace Status {
        type Dictionary = { [K in Status as Uppercase<K>]: K }
      }
      type Success = { status: Status.Dictionary['SUCCESS']; body: Json }
      type Error = { status: Status.Dictionary['ERROR']; reason: string }
    }
    type Response = Response.Success | Response.Error
  }
  //#endregion
  //#region Spreadsheet
  namespace Spreadsheet {
    type Config = { spreadsheetKey: string; sheetName: string }
    type Row = Array<*>
    type Data = Record<string, *>
    type IndexForKeyMap = Map<string, number>
    type IdField = { key: string; index: number; value: string }
    //#region Filter
    namespace Filter {
      namespace Operator {
        type ForEquity = '=' | '!='
        type ForComparison = '>' | '>=' | '<' | '<='
        type ForString = ForEquity
        type ForNumber = ForEquity | ForComparison
        type ForBoolean = ForEquity
      }
      type ForString = string | { value: string; operator?: Operator.ForString }
      type ForNumber = number | { value: number; operator?: Operator.ForNumber }
      type ForBoolean = boolean | { value: boolean; operator?: Operator.ForBoolean }
    }
    type Filter = Filter.ForString | Filter.ForNumber | Filter.ForBoolean
    namespace Filter {
      type Dictionary = Record<string, Filter>
      type IndexedMap = Map<number, Filter>
    }
    //#endregion
    type Search = { columnIndex: number; term: string }
  }
  //#endregion
}
//#endregion
//#region Lib.DependencyManager
declare namespace Lib {
  namespace DependencyManager {
    namespace Methods {
      type Register = <T extends Types.ClassDef>(classDef: T, factory: () => InstanceType<T>) => void
      type Resolve = <T extends Types.ClassDef>(classDef: T) => InstanceType<T>
    }
  }
  interface DependencyManager {
    register: DependencyManager.Methods.Register
    resolve: DependencyManager.Methods.Resolve
  }
}
declare class DependencyManager implements Lib.DependencyManager {
  constructor()
  register: Lib.DependencyManager.Methods.Register
  resolve: Lib.DependencyManager.Methods.Resolve
}
//#endregion
//#region Lib.SpreadsheetsManager
declare namespace Lib {
  namespace SpreadsheetsManager {
    type Deps = {
      spreadsheetApp: GoogleAppsScript.Spreadsheet.SpreadsheetApp
      propsService: GoogleAppsScript.Properties.PropertiesService
      lockService: GoogleAppsScript.Lock.LockService
      lockTimeout?: number
    }
    namespace Methods {
      type Get = (
        params: Types.Spreadsheet.Config & { filters?: Types.Spreadsheet.Filter.Dictionary }
      ) => Types.Spreadsheet.Data[]
      type Save = (params: Types.Spreadsheet.Config & { data: Types.Spreadsheet.Data; idFields: string[] }) => void
      type Insert = (params: Types.Spreadsheet.Config & { data: Types.Spreadsheet.Data[] }) => void
      type Update = (
        params: Types.Spreadsheet.Config & {
          set: Types.Spreadsheet.Data[]
          idFields: string[]
          criteria?: Types.Spreadsheet.Filter.Dictionary
        }
      ) => void
      type Replace = (
        params: Types.Spreadsheet.Config & {
          data: Types.Spreadsheet.Data[]
          criteria?: Types.Spreadsheet.Filter.Dictionary
        }
      ) => void
      type Delete = (params: Types.Spreadsheet.Config & { criteria?: Types.Spreadsheet.Filter.Dictionary }) => void
    }
  }
  interface SpreadsheetsManager {
    get: SpreadsheetsManager.Methods.Get
    save: SpreadsheetsManager.Methods.Save
    insert: SpreadsheetsManager.Methods.Insert
    update: SpreadsheetsManager.Methods.Update
    replace: SpreadsheetsManager.Methods.Replace
    delete: SpreadsheetsManager.Methods.Delete
  }
}
declare class SpreadsheetsManager implements Lib.SpreadsheetsManager {
  constructor(deps: Lib.SpreadsheetsManager.Deps)
  get: Lib.SpreadsheetsManager.Methods.Get
  save: Lib.SpreadsheetsManager.Methods.Save
  insert: Lib.SpreadsheetsManager.Methods.Insert
  update: Lib.SpreadsheetsManager.Methods.Update
  replace: Lib.SpreadsheetsManager.Methods.Replace
  delete: Lib.SpreadsheetsManager.Methods.Delete
}
//#endregion
//#region Lib.CacheManager
declare namespace Lib {
  namespace CacheManager {
    namespace Methods {
      type Set = <T>(params: { scope: Types.ClassDef; method: Types.MethodDef<T>; id?: string; value: T }) => void
      type Get = <T>(params: { scope: Types.ClassDef; method: Types.MethodDef<T>; id?: string }) => T | undefined
      type Flush = (params: { scope: Types.ClassDef }) => void
      type Handle = <T>(params: {
        scope: Types.ClassDef
        method: Types.MethodDef<T>
        id?: string
        handler: () => T
      }) => T
    }
  }
  interface CacheManager {
    set: CacheManager.Methods.Set
    get: CacheManager.Methods.Get
    flush: CacheManager.Methods.Flush
    handle: CacheManager.Methods.Handle
  }
}
declare class CacheManager implements Lib.CacheManager {
  constructor()
  get: Lib.CacheManager.Methods.Get
  set: Lib.CacheManager.Methods.Set
  flush: Lib.CacheManager.Methods.Flush
  handle: Lib.CacheManager.Methods.Handle
}
//#endregion
//#region AppClient
namespace Lib.AppClient {
  interface Methods {
    getAppId: (key: string) => string
    call: (params: Types.AppCall.Request) => Types.AppCall.Response
    callWithAuth: Methods['call']
  }
}
const AppClient: { new (): Lib.AppClient.Methods }
//#endregion
