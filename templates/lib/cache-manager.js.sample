/** @implements {Lib.CacheManager} */
class CacheManager {
  constructor() {
    /** @type {Map<string, Map<string, *>>} */
    this._cache = new Map()
  }

  /** @type {Lib.CacheManager.Methods.Set} */
  set({ scope, method, id, value }) {
    const scopeKey = this._getScopeKey(scope)
    let cachedScope = this._cache.get(scopeKey)
    if (cachedScope === undefined) cachedScope = new Map()
    const methodKey = this._getMethodKey(method, id)
    cachedScope.set(methodKey, value)
    this._cache.set(scopeKey, cachedScope)
  }

  /** @type {Lib.CacheManager.Methods.Get} */
  get({ scope, method, id }) {
    const scopeKey = this._getScopeKey(scope)
    const cachedScope = this._cache.get(scopeKey)
    if (cachedScope === undefined) return undefined
    const methodKey = this._getMethodKey(method, id)
    const cachedMethod = cachedScope.get(methodKey)
    return cachedMethod
  }

  /** @type {Lib.CacheManager.Methods.Flush} */
  flush({ scope }) {
    const scopeKey = this._getScopeKey(scope)
    this._cache.delete(scopeKey)
  }

  /** @type {Lib.CacheManager.Methods.Handle} */
  handle({ scope, method, id, handler }) {
    const cached = this.get({ scope, method, id })
    if (cached !== undefined) return cached
    const value = handler()
    this.set({ scope, method, id, value })
    return value
  }

  /**
   * @template T
   * @param {Lib.Types.MethodDef<T>} method
   * @param {string} [id]
   * @returns {string}
   */
  _getMethodKey(method, id = '') {
    const key = `${this._checkIfNotEmptyString(method.name)}${id === '' ? '' : `::${id}`}`
    return key
  }

  /**
   * @param {Lib.Types.ClassDef} scope
   * @returns {string}
   */
  _getScopeKey(scope) {
    const key = this._checkIfNotEmptyString(scope.name)
    return key
  }

  /**
   * @param {*} key
   * @returns {string}
   */
  _checkIfNotEmptyString(key) {
    if (typeof key !== 'string') throw new Error('Unexpected type for key')
    if (key === '') throw new Error('Unexpected empty key')
    return key
  }
}
