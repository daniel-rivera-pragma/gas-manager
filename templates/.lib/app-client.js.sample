/** @implements {Lib.AppClient.Methods} */
class AppClient {
  constructor() {
    /** @type {Lib.Types.AppCall.BaseUrl} */
    this._baseUrl = 'https://script.google.com'
    /** @type {Lib.Types.AppCall.Response.Status.Dictionary} */
    this._statuses = { SUCCESS: 'success', ERROR: 'error' }
    /** @type {Lib.Types.AppCall.Env.Key} */
    this._envKey = 'APP_CALL_ENV'
    /** @type {Lib.Types.AppCall.Env.Dictionary} */
    this._envNames = { DEV: 'dev', PDN: 'pdn' }
    /** @type {Map<string, string>} */
    this._props = new Map()
  }

  /**
   * @param {string} url
   * @param {Lib.Types.Json} payload
   * @param {boolean} [withAuth]
   * @returns {Lib.Types.AppCall.Response}
   */
  _call(url, payload, withAuth = false) {
    /** @type {GoogleAppsScript.URL_Fetch.URLFetchRequestOptions} */
    const options = {
      method: 'post',
      contentType: 'application/json',
      payload: JSON.stringify(payload),
      muteHttpExceptions: true,
    }
    if (withAuth) {
      const token = ScriptApp.getOAuthToken()
      if (token === '') throw new Error('Unexpected empty OAuth token')
      options.headers = {
        Authorization: `Bearer ${token}`,
      }
    }
    const { SUCCESS, ERROR } = this._statuses
    const response = UrlFetchApp.fetch(url, options)
    const code = response.getResponseCode()
    const rawBody = response.getContentText('utf-8')
    if (code !== 200) return { status: ERROR, reason: rawBody }
    try {
      const body = JSON.parse(rawBody)
      return { status: SUCCESS, body }
    } catch (error) {
      const reason = `ParseError${error instanceof Error ? `: ${error.message}` : ''}`
      return { status: ERROR, reason }
    }
  }

  /**
   * @param {string} [id]
   * @param {string} [key]
   * @param {string} [org]
   * @returns {string}
   */
  _parseUrl(id, key, org = '') {
    const appId = this._getAppId(id, key)
    const envName = this._getAppEnv()
    const requestPath = `${org === '' ? 'macros' : `a/macros/${org}`}/s/${appId}/${envName === this._envNames.DEV ? 'dev' : 'exec'}`
    const url = `${this._baseUrl}/${requestPath}`
    return url
  }

  _getAppEnv() {
    const { DEV, PDN } = this._envNames
    const prop = this._props.get(this._envKey)
    if (prop === DEV || prop === PDN) return prop
    let envName = PropertiesService.getScriptProperties().getProperty(this._envKey)
    if (envName === null || envName === '') envName = PDN
    if (envName !== DEV && envName !== PDN) throw new Error('Unexpected no valid env name')
    this._props.set(this._envKey, envName)
    return envName
  }

  /**
   * @param {string} [id]
   * @param {string} [key]
   */
  _getAppId(id = '', key = '') {
    if (id !== '') return id
    if (key === '') throw new Error('Unexpected id and key empty')
    const prop = this._props.get(key)
    if (prop !== undefined) return prop
    const appId = PropertiesService.getScriptProperties().getProperty(key)
    if (appId === null) throw new Error(`Unexpected not found key '${key}'`)
    if (appId === '') throw new Error(`Unexpected empty id retrieved from key '${key}'`)
    this._props.set(key, appId)
    return appId
  }

  /** @param {Lib.Types.AppCall.Request} params */
  call({ id, key, payload, org }) {
    return this._call(this._parseUrl(id, key, org), payload)
  }

  /** @param {Lib.Types.AppCall.Request} params */
  callWithAuth({ id, key, payload, org }) {
    return this._call(this._parseUrl(id, key, org), payload, true)
  }
}
